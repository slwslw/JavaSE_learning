logback使用步骤：

1. 在当前项目下导入logback相关jar文件，并添加到项目工程资源库中
2. 把logback核心配置文件，复制到当前项目工程的src目录下
3. 在开发的类中，创建logback对象，使用logback中的API方法记录日志信息



logback日志级别：

1. trace     //追踪
2. debug   //调试（程序有bug，测试bug使用的）
3. info   //关键信息
4. warn    //警告
5. error    //错误







## 异常

什么是异常？

- 程序在运行过程中，发生了不正常的情况，造成程序中断向下执行



有异常了怎么办呢？

- 当前发生异常的代码位置处，有处理异常的代码，那么异常就会被处理掉，程序继续执行
- 当前发生异常的代码位置处，没有处理异常的代码(程序中没有处理异常的代码)，最终异常会抛出给JVM来处理
  - JVM处理异常的方式：
    1. 打印异常的信息（异常的类型、异常发生的位置、异常的原因）
    2. JVM停止



异常处理的方式：

1. 声明：throws
   - 遇到异常发生了，自己不处理，交给别人处理
     - 最终还是需要有一个位置使用try..catch来处理异常
       - 结论：在main方法中，只能使用try..catch
2. 捕获：try..catch
   - 遇到异常发生了，自己处理





使用声明的方式处理异常：

~~~java
//使用声明的方式处理异常，声明是书写在方法定义上
修饰符号  返回值类型 方法名(参数类型 参数,...) throws 异常类1 , 异常类2 ， .... 
{
    
}
~~~

~~~
//在定义方法时，使用声明的方式处理异常
public void method(String name) throws NullPointerException {
   //
}
~~~







Java基础面试题 ： throws和throw的区别

- throws ： 声明

- throw ： 抛出 （手动引发异常）

  - 程序员手动创建一个异常对象，并招抛出给调用者

  ~~~ java
  //把创建的异常类对象抛出给调用者
  throw new RuntimeException("参数不能为空");
  ~~~

  





异常处理有两种：声明、捕获，在程序开发中到底怎么选择使用哪个呢？

- 自定义方法（程序员自己写的方法），通常都可以使用：声明

  - 方法体内代码比较清爽（阅读性好）
  - 把异常统一抛出到main方法中，进行统一的处理

- 捕获的使用场景：

  1. main方法中只能使用捕获

  2. 父类型中的方法不支持throws，在子类重写方法时，重写的方法只能使用：捕获

     ~~~java
     public class Demo  extends Thread{
         //重写方法
         public void run(){
     
             try {
                 Thread.sleep(100);
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
         }
     }
     ~~~

     





Throwable类  //异常的顶层父类型

- 子类：Error类（错误类） //异常处理无法解决错误

- 子类：Exception类（异常类）//可以使用异常处理解决（保证程序运行过程中不会中断）



编译时异常：Exception类

运行时异常：RuntimeException类  （继承了Exception）





自定义异常：

- 程序员自己编写的异常类

- 解决问题： JDK提供的异常类在命名上做不到见名其知意，通常在开发中程序员会自定义自己的异常类（见名其知意）

- 使用：

  ~~~java
  public 自定义异常类 extends Exception{ //当前自定义异常类为：编译时异常
      public 自定义异常类(){
          //super();//调用父类中的无参构造方法
      }
      public 自定义异常类(String message){
          super(message);
      }
  }
  
  public 自定义异常类 extends RuntimeException{ //当前自定义异常类为：运行时异常
      
  }
  ~~~

  



上午内容：

- 异常

  ~~~java
  //什么是异常
  程序在运行过程中发生了一些不正常情况，造成程序运行的中断
  
  
  //异常处理解决程序中的什么问题
  当程序中发生异常后，确保程序不能中断（跳过异常部分的代码，执行后续的代码）
  
  
  //异常处理怎么使用
  1、声明：throws       自己不处理交给他人处理
  2、捕获：try...catch  自己处理   
  
      
  public void method() throws 异常类 {
      //有编译时异常：throws、try...catch
  }    
  //默认的异常处理方式：向上抛出
  public void show() {
      //有运行时异常： try...catch | throws
  }
  
  publi void hello(){
      try{
          
          //可能会发生异常的代码
          
          
      }catch(Exception e){
          //处理异常
          //日志记录异常信息
      }
  }
      
      
  
  异常在使用中的注意细节
  try{
      
  }catch(异常子类 e){
      
  }catch(异常子类 e){
      
  }...
   catch(异常父类 e){
       
  } 
  
  main方法只能使用：try..catch
      
  
  //自定义异常
  public class 自定义异常类 extends RuntimeException{
      public 自定义异常类(){}
      public 自定义异常类(String message){
          super(message);
      }
  }   
  
  if( 参数 == null){
      //手动引发异常，并抛出
      throw new 自定义异常类("异常消息");
  }
  ~~~

  









## Lambda

lambda作用：

- 简化程序中的匿名内部类代码书写



lambda表达式：

- 前置要求：仅针对==函数式接口==进行代码编写

  - 函数式接口的特点：接口中仅有一个抽象方法（允许有：静态方法、默认方法、私有方法）

  ~~~java
  @FunctionalInterface    //java针对函数式接口，制定了一个注解：@FunctionalInterface
  public interface Comparator<T> {
      .......
  }
  ~~~

- 标准语法：

  ~~~java
  (参数 , ....) -> {
      //方法体代码（要做什么事情）
  }
  ~~~

  - （） ： 代表的是一个方法
  - ->    ：  指向要做的事情
  - { }  ： 功能代码（具体要做事情的代码）

 



Lambda表达式的省略模式：

1. 可以省略参数类型：要么全部省略，要么全部保留
2. 如果参数仅有一个时，可以省略小括号
3. 如果代码块中仅有一行代码，可以省略：大括号、分号、return













## Stream流

stream流的作用：

- 针对集合进行功能简化开发



Stream流的使用通常需要Lambda表达式



Stream流方法分类：

1. 获取方法：获取流（创建一个流水线）
2. 中间方法：在流水线进行操作（例：过滤、截取）
3. 终结方法：流水线上的操作结束了，要关闭流水线





获取Stream流对象：

~~~java
//单列集合：Collection[ List、Set ]
Stream 流对象 = 单列集合对象.stream();


//双列集合：Map （不能直接获取流对象）
1. 先通过keySet()或entrySet()，获取到Set集合
2. Stream  流对象 = Set集合对象.stream();    


//数组
Stream 流对象 = Arrays.stream( 数组 );

//特殊的操作： Stream流中的静态方法：  static<T> Stream<T>  of( T... args )
Stream 流对象 = Stream.of( 同一种类型元素 ,同一种类型元素,同一种类型元素, ... );
~~~



























