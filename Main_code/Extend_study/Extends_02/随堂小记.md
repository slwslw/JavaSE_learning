就业班课程：

- JavaSE进阶
- 数据库
- 前端技术
- web开发
- 框架技术
- 项目1
- 微服务技术
- 项目2
- 项目3





每天学习任务

1. 完成课堂上所有代码练习 （早于学员笔记）
2. 整理当天学习内容（以学员笔记为主[重点、难点]）
3. 完成布置的作业
4. 预习下次课内容





面向对象三大特征：

1. 封装
2. 继承
3. 多态



学习技巧：

问题1：什么是继承

~~~
继承发生前提：当多个类中有相同的属性和行为时，把这些相同的属性和行为，抽取出来封装一个独立的类中

在Java中使用继承(extends)，来继承这些封装了公共属性和行为的类（父类）

继承：有父类、有子类


结论：让一个类(子类、派生类)继承另一个类(父类、超类、基类)
~~~

问题2：继承解决程序中的什么问题？

~~~
1、程序中代码的复用性（重复的代码抽取出来，封装到父类中，子类继承后就可以直接使用）
2、建立类和类之间的关系
~~~

问题3：继承怎么使用？ //写代码

~~~java
public class 父类{
    //共性成员
}

public class 子类 extends 父类{
    //子类可以使用父类中定义的内容
}
~~~

问题4：继承在使用中有使用注意细节

~~~
1、Java只能单一继承(不能多继承)，允许多层次继承
2、在子类继承父类后，就直接可以父类中非私有的成员（成员变量、成员方法）
3、在继承中，访问成员变量或成员方法的原则：就近原则（先在子类中查找，子类没有再去父类中查找）
    super.父类中的成员变量
    super.父类中的成员方法
4、当父子类中存在一模一样的成员方法时，这种情况称为：方法重写
5、在继承中，要先初始化父类对象（ 通过子类构造方法中的super()来调用父类的无参构造 ）
   //调用父类有参构造方法： super(参数,....);
~~~







方法的体现：

1. 重载
   - 在本类中发生
   - 方法名相同
   - 方法的参数列表不同（类型不同、数量不同、顺序不同）
   - 和返回值没有任何关系
2. 重写
   - 发生在父子类(继承)中
   - 子类中的方法和父类的方法一模一样





方法重写：

1. 什么是方法重写
2. 方法重写解决什么问题
3. 方法重写怎么实现
4. 方法重写有什么注意细节





this关键字的使用：

~~~java
//访问本类中的成员变量
this.成员变量名=数据值;

//访问本类中的成员方法
this.成员方法();

//访问本类中的构造方法（要求：只能使用某个构造方法，去调用本类中另一个构造方法）
public ClassName(){
    
}
public ClassName(String name){
    this(); //调用无参构造方法
}
~~~

















学习套路：

1. 这个技术是什么？
2. 这个技术可以解决什么问题？  （重点）
3. 这个技术怎么使用？                  （重点）
4. 这个技术在使用中的注意细节





回顾上午内容：

- 继承

  - 继承是什么

    ~~~java
    让一个类继承另一个类
    关键字：extends
    ~~~

  - 继承可以解决什么问题

    ~~~
    1、建立类与类之间的关系：父子关系
    2、可以解决程序中代码的复用性（子类可以直接使用父类中的非私有成员）
    ~~~

  - 继承怎么使用

    ~~~java
    public class 父类{
        //成员
    }
    public class 子类 extends 父类{
        //子类可以直接使用父类中的非私有成员
    }
    ~~~

  - 继承在使用中的注意细节

    ~~~java
    1、Java语言只支持单一继承(不能多继承) ， 允许多层次继承
    2、子类不能继承父类中的私有成员
    3、当子类和父类中存在相同的成员时，访问原则：就近原则
       super.成员变量 
       super.成员方法()
       super()
       super(参数, ...) 
    4、子类对象在实例化完成之前，必须先初始化父类对象（只有父类初始化完成后子类才可以访问父类成员）
       //子类构造方法在执行时，有隐藏代码：super()  //默认调用父类中的无参构造方法    
    ~~~

- 方法重写

  - 什么是方法重写

    ~~~java
    当父子类中存在一模一样的非私有成员方法时，就可以称为：子类重写父类的方法（方法重写）
    ~~~

  - 方法重写可以解决什么问题

    ~~~
    当父类中的方法，子类在调用时无法满足子类的要求，就可以在子类中重写父类的方法
    
    目的：
    1. 为后面学习多态准备
    2. 不愿意在起一个方法名
    ~~~

  - 方法重写怎么使用

    ~~~java
    public class 父类{
        public void show(String name){
            ....
        }
    }
    
    public class 子类 extends 父类{
        //重写方法
        @Override
        public void show(String name){
            //重新编写方法体业务代码
        }
    }
    ~~~

  - 方法重写的注意细节

    ~~~
    1、针对父类中私有方法不能重写
    2、必须和父类中的方法一模一样
    ~~~

    





JVM内存划分：

1. 栈   //方法运行在栈内存中
2. 堆   //对象存储于堆内存中
3. 方法区  //存放加载的.class文件       //方法区有由N多个不同功能的小区域组成
4. 寄存器  
5. 本地方法区









this：当前类对象引用

~~~java
this.成员方法()
this.成员变量 = 数据值
this() //本类无参构造方法
this("字符串")//本类带有String类型参数的构造方法    
~~~

super：父类对象引用

~~~java
super.成员方法()
super.成员变量 = 数据值
super() //父类无参构造方法
super("字符串")//父类带有String类型参数的构造方法   
~~~





~~~java
//父类：动物类
public abstract class Animal{
    //抽象方法：必须使用关键字abstract修饰
    //抽象方法：必须书写在抽象类中
    public abstract void eat();//在java语言中没有方法体的方法，称为：抽象方法 
}
~~~



普通类:

~~~java
public class 类名{
    //成员变量
    private String name;
    
    //成员方法
    public void setName(String name){
        this.name = name;
    }
    
    //构造方法
    public 类名{
        
    }
}
~~~

抽象类：

~~~java
public class 类名{
    //成员变量
    private String name;
    
    //成员方法
    public void setName(String name){
        this.name = name;
    }
    
    //构造方法
    public 类名{
        
    }
    
    //抽象方法
    public abstract void 抽象方法();
}
~~~

- 抽象类，不能实例化（不能创建对象）
  - 疑问：既然不能创建对象了，为什么还要有构造方法？
    - 抽象类通常是用于父类，创建子类对象时，需要先初始化父类（抽象方法中构造方法的作用就是用于父类初始化使用）
- 抽象类中的抽象方法，必须由子类重写









什么是设计模式？

- 设计模式，就是一种解决方案（解决开发中某个问题的方案）

设计模式解决什么问题？

- 在开发中一些常见问题，可以使用设计模式解决





模板设计模式：

- 模板：就一个固定的格式
- 模板设计：把确定的内容，提前准备好，把不确定的内容，定义为抽象方法（由子类重写）







创建对象：

~~~java
Student stu = new Student(); //有名字的对象

//对象名： stu
~~~

匿名对象：

- 没有名字的对象

~~~java
new Student(); //创建的对象没有名字
new Student("张三",23);
~~~



























