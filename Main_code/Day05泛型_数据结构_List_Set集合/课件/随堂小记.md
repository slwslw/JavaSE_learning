

BigDecimal类存在的问题：精度丢失

~~~java
BigDecimal num = new BigDecimal( 100 ); //会有精度丢失的问题

BigDecimal 大浮点对象 = new BigDecimal( "100" ); //推荐使用方式


BigDecimal  返回值 = 大浮点对象.add( BigDecimal 参数 )
~~~





迭代器的使用步骤：

~~~java
//1、通过集合对象，获取迭代器对象
Iterator  it  = 集合对象.iterator();

//2、使用迭代器对象中的API方法，获取集合中的每一个元素
while( it.hasNext() ){
    //取出每一个元素
    Object obj = it.next()
}
~~~

在开发中为了方便程序员的书写，把迭代器进行简化：   增强for

~~~java
//增强for底层 ：还是迭代器

for(元素类型 变量 : 集合){
    
}
~~~









今天课程：

1. 泛型
2. 数据结构
3. List集合、Set集合











## 泛型

泛型是什么？

~~~
在java语言中，是一种类型参数，可以设置存储数据的类型
~~~



泛型解决程序中什么问题？

~~~
在创建集合对象时，明确了集合中所存储元素的类型（限定类型）
~~~

- 泛型在使用在代码编写时期的技术方式（编译期技术）
- 泛型在程序运行后，就擦除



泛型的使用

- 泛型类

  ~~~ java
  public class 类名<T>{
      
  }
  
  //当不确定类中的某个属性使用什么类型时，可以用泛型表示
  public class 泛型类<T>{
      
      private T 变量;
  }
  
  //在创建泛型类对象时，明确类型
  泛型类<Integer> 对象 = new 泛型类<Integer>();//泛型类中成员变量的类型为：Integer
  
  泛型类<String> 对象 = new 泛型类<String>();//泛型类中成员变量的类型为：String
  
  ~~~

- 泛型接口

  ~~~java
  public class 接口名<T>{
      
  }
  
  //当不确定接口中的某个方法参数使用什么类型、或方法的返回值使用什么类型时：可以用泛型表示
  public interface 泛型接口<T>{
      public void method(T a);
  }
  
  //情况1：在子类编写时，指定接口上泛型的具体类型
  public class 子类 implements 泛型接口<String>{
      //方法重写
      public void method(String a){
          
      }
  }
  //情况2：在子类编写时，没有指定接口上的泛型。 意味着：子类也使用和接口相同的泛型了（子类：泛型类）
  public class 子类<T> implements 泛型接口<T>{
      //方法重写
      public void method(T a){
          
      }
  }
  子类<Integer> 对象 = new 子类<>();//创建子类对象时，明确了泛型的类型
  ~~~

- 泛型方法

  ~~~java
  //语法格式
  修饰符号 <泛型> 返回值类型 方法名( 泛型 参数1 , ...){
      //方法体
  }
  
  //当前类没有声明为泛型类，但该类中的方法参数或方法返回值不确定类型时： 使用泛型方法
  public <T> void method(T param){
      
  }
  //当调用方法时，向方法中传递参数的类型，就是泛型的类型
  
  
  ~~~

  











泛型中的通配符：  ?   (任意类型)

- 通常在开发中，?是和泛型的上下限一起使用



泛型的下限

~~~java
//指定泛型中的最小类型
<? super 最小类型>
    
? 可以是最小类型
? 可以是父类型    
~~~

泛型的上限

~~~java
//指定泛型中的最大类型
<? extends 最大类型>
    
? 可以是最大类型
? 可以是子类型    
~~~









你们认为什么是数据结构？

~~~
数据结构：就是一种存储数据的排列方式
~~~

常见的数据结构：

1. 栈（先进后出）
2. 队列（先进先出）  //数组就是这种方式
3. 链表
4. 哈希表
5. 树
   - 二叉树
   -  平衡二叉树
   - 红黑树







队列数据结构： （队列是一种线性结构）

- 特点：先进先出
- 数组

















回顾上午内容：

- 泛型

  1. 泛型是什么

     ~~~java
     泛型是一种类型参数，可以设置存储的类型
     ~~~

  2. 泛型解决程序中的什么问题

     ~~~java
     在创建集合时，使用泛型约束所存储的元素类型。好处：在使用时不需要强制转换    
     ~~~

  3. 泛型怎么使用

     ~~~java
     //泛型在使用时的划分： 泛型类、泛型接口、泛型方法
     
     //泛型类： 当类中的某个属性类型不确定时，可以使用泛型来表示
     public class 类名<E,T>{
         private String name;
         private E param;//不确定属性的类型
         
         public void method(T arg){       
         }
     }
     类名<String,Integer> 对象 = new 类名<>();
     对象.method( Integer类型的参数 );
     
     
     //泛型接口： 当接口中某个方法的参数或返回值不确定类型时，可以使用泛型来表示
     public interface 接口名<T>{
         public void method(T param);
         public T show(T args);
     }
     class 子类 implements 接口名<String>{
         //子类在实现接口时，明确了接口上泛型的类型（String类型）
     }
     class 子类<T> implements 接口名<T>{
         //子类继续延伸使用接口上的泛型
         //子类就变为： 泛型类
     }
     
     
     //泛型方法（提前：非泛型类）：当类中的某个方法的参数不确定或返回值不确定时，使用泛型方法
     public class 类名{
         //泛型方法
         public <T> void 方法名(T 参数名){
             
         }
         public static <T> T 方法名(T 参数名){
             
         }
     }
     String 结果 = 类名.方法名( String类型 ) 
     ~~~

  4. 泛型在使用中的注意细节

     - 泛型不支持多太态

       ~~~java
       ArrayList<Person> list = new ArrayList<Student>(); //报错
       ~~~

     - 泛型在语法上支持：通配符 ？   //表示任意类型

       ~~~java
       ArrayList<?> list = new ArrayList<Student>();
       ~~~

     - 泛型中的通配符，通常会配置上下限使用

       ~~~java
       //泛型上下限，通常用于方法定义时
       
       //上限
       public void method(ArrayList<? extends 父类型>  list){
           //传递的list集合对象中存储的元素必须是：父类型 或 其子类型
       }
       
       //下限
       public void method(ArrayList<? super 子类型>  list){
           //传递的list集合对象中存储的元素必须是：子类型 或 其父类型
       }
       ~~~

- 数据结构：栈、队列

  ~~~
  什么是数据结构？
  存储数据时，底层对数据排列的方式
  
  常见数据结构： 栈、队列、数组、链表、哈希表、树
  
  计算机底层最原始的数据结构仅有两种： 线性结构、非线性结构
  
  栈特点：先进后出
  队列特点：先进先出
  ~~~







数组结构：

- 数组在内存中的体现是一块连续存储数据的空间

- 查询快
- 增删元素效率慢
- 在已学习的ArrayList集合，底层就是使用：数组结构



ArrayList集合的特点：查询快、增删慢













## List集合

Java语言中集合体系划分：

- Collection  (接口)
- Map （接口）



java.util.Collection集合：    是一个接口（无法实例化）

- java.util.List集合（接口）
  - 常用子类：ArrayList 、 LinkedList
- java.util.Set集合（接口）





java.util.List集合：

- 带有索引
- 存储的元素的顺序和获取元素的顺序一致
- 可以存储重复元素



因为List集合可以使用索引，故围绕着索引，设计很多API方法：

~~~java
//添加元素
List集合.add( 索引 ， 元素值) //向List集合中指定索引位置上，添加元素
                           //如指定索引位置上已有索引，会自动后向移动

//修改元素
List集合.set( 索引 ， 元素值) //修改List集合中指定索引位置上的元素值    

//删除元素
List集合.remove(索引) //删除List集合中指定索引位置上的元素值    

//获取元素
List集合.get(索引);
~~~



HashMap集合







ArrayList集合：

- 实现List接口（List接口中的所有功能都有）
- 底层使用：数组
  - 查询快 、 增删慢





LinkedList集合：

- 实现List接口 
- 底层使用：双向链表（有头有尾）
  - 增删快 、 查询慢

- 特有方法都围绕着链表头和尾设计

  ~~~java
  //添加元素
  addFirst( 元素 ) //把元素添加到链表头部
  addLast( 元素 )  //把元素添加到链表尾部    
  
  
  //删除元素
  removeFirst()
  removeLast()    
  
  
  //获取元素
  getFirst()
  getLast()    
  
  ~~~

  









链表结构：

- 在内存中是使用==节点==来存储数据
  -  节点 = 数据 + 地址

- 链表：有头、有尾
- 分类：
  1. 单向链表：只能从头到尾
  2. 双向链表：可以从头到尾，也可以从尾到头 （提高查询效率）
- 代表集合类：LinkedList









Collection集合

- List集合

  1. 有索引
  2. 存取元素有序
  3. 可能存储重复元素

- Set集合

  1. 没有索引
  2. 存取元素不保证顺序
  3. 不允许存储重复元素

  

Set集合中方法全部来自Collection集合

Set集合的子类：

- HashSet集合

  - 特点：

    1. 没有索引
    2. 存取元素不保证顺序
    3. 不能存储重复元素

  - 底层使用：哈希表结构

    

- LinkedHashSet集合

- TreeSet集合









哈希表数据结构：

- 底层是使用大小为16的数组+链表组成的存储方式

- 哈希表存储数据的方式  （ 借助：哈希值[存储位置] ）

  ~~~
  拿要存储的元素，结合哈希算法， 计算出哈希值(存储位置) // 调用：  元素.hashCode()
  
  判断 ： 计算出的存储位置上是否有元素存在    
         情况1 ： 没有元素存在     =>  直接存储
         情况2 ： 已有元素存在
                 拿要存储的元素 和 已经存在的元素 进行比较（比较内容是否相同） //元素.equals() 
                 相同： （重复元素）  =>  不存储
                 不相同： （不重复元素）
                        再次拿当前存储空间作为算法因子，再次进行哈希算法，计算新的存储空间
                        
  
  ~~~

- 从JDK1.8开始，哈希表底层进行优化，使用：数组+链表/红黑树

  - 从链表 => 红黑树时机：  当链表的长度>8，自动 把链表转换为红黑树





Set集合：

- HashSet
  - 底层：哈希表结构
  - 特点：
    1. 不能存储重复元素
    2. 没有索引
    3. 存取元素顺序不保证一致
- LinkedHashSet
  - 特点：
    1. 没有索引
    2. 不能存储重复元素
    3. 存取元素顺序一致
  - 底层：哈希表+链表（保证存储元素的顺序）
- TreeSet

















