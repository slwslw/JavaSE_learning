今天课程优先级：

1. Map集合
2. TreeSet集合
3. 可变参数
4. .......















Collection（接口）

- List（接口）

  - 特点：

    1. 有索引
    2. 存取元素有序
    3. 允许存储重复元素

  - 常用子类：

    - ArrayList

      - 特性：
        1. 底层使用数组结构
        2. 查询快、增删慢
        3. 具有List集合中的特点

    - LinkedList

      - 特性:

        1. 底层使用双向链表结构（有头有尾）

        2. 增删快 、查询慢

        3. 具有自己的特有方法（围绕着链表的头和尾设计）

           ~~~java
           Object getFirst();
           Object getLast();    
           ~~~

- Set（接口）

  - 特点：
    1. 没有索引
    2. 存取元素不保证顺序
    3. 不允许存储重复元素
  - 常用子类：
    - HashSet
      - 特性：
        1. 底层使用哈希表结构（哈希表去重原理：存储的元素必须重写hashCode、equals方法）
        2. JDK1.8底层优化了哈希表（当链表长度超出8，就自动转为红黑树）
    - LinkedHashSet
      - 特性：
        1. 底层使用哈希表+链表的结构
        2. 哈希表用来去重、链表用来保证存取元素的顺序
    - TreeSet
      - 特性：
        1. 底层使用树(红黑树)结构
        2. 不能存储重复元素
        3. 不具备索引
        4. 存储的元素会按照规则进行排序

泛型：

~~~java
//在开发中使用泛型最多的就是：创建集合时使用泛型约束所存储元素的类型
List<Student> studentList = new ArrayList<>();
~~~









TreeSet集合：

- 具有对所存储元素进行排序的功能

在TreeSet集合中存储：String、Integer、Double、Character //JDK提供的类型

- 都默认已实现了java.lang.Comparable接口 （自带自然排序规则）

在TreeSet集合中存储：自定义类型      //程序员自己定义的

- 就必须保证自定义类型，有实现java.lang.Comparable接口，并重写compareTo方法
- 如果自定义类型，没有实现Comparable接口，在存储到TreeSet集合中时，会引发异常



compareTo方法：

~~~java
//比较大小：  0表示相同  、 负数表示小    正数表示大
public int compareTo(E e){ 
    自然排序规则
    
    
    //返回值有三种： 正数 、 负数 、 0  （底层红黑树需要）
}
~~~



二叉树：

- 以根节点为坐标，小于根节点的数据存储在左边，大于根节点的数据存储在右边











TreeSet集合：

- 底层使用：红黑树
  - 去重、排序（拿树中已存在的元素 ， 和要存储的元素进行比较[比较大小：0、正数、负数] ）
- 存储自定义元素，要保证自定义元素有实现java.lang.Comparable接口



JDK提供的：String、Integer 等类，都已具备自然排序（实现Comparable接口）

- String类默认就已有排序规则（按照字典顺序从小到大排序）



需求：在TreeSet中存储的String类型数据，按照字符串长度从大到小排序

- 结论：使用自然排序做不到（String类是final修饰，不能继承）
- 解决方案：不使用自然排序，使用其他排序方式（比较器）



排序方式：

1. 自然排序： 元素必须实现Comparable接口
2. 比较器排序： 元素不需要实现Comparable接口（需要在创建TreeSet对象时，指定排序规则）



TreeSet构造方法：

~~~java
public TreeSet() //默认使用自然排序
public TreeSet( Comparator c ) //指定比较器对象    
~~~

Comparator接口（泛型接口）： 比较器

~~~java
int  compare(Object obj1 , Object obj2) //比较两个元素的大小： 0、正数、 负数
~~~









回顾上午内容：

- TreeSet集合

  - 特点：

    1. 底层使用红黑树结构
    2. 不能存储重复元素（去重）
       - 拿要存储的元素和树结构中已经存在的元素进行比较：
         - 0：重复元素
         - 负数：向树的左边
         - 正数：向树的右边
    3. 没有索引
    4. 存储的元素会按照指定规则进行排序

  - 排序规则：

    1. 自然排序

       - 元素自身要具备排序方式（要实现Comparable接口）
         - JDK中的提供的现成类：String、Integer、.....  都自带自然排序
         - 程序员自定义的类，要实现Comparable接口（具备自然排序）

       ~~~java
       TreeSet<Integer> set = new TreeSet<>();
       set.add(100);set.add(99);set.add(200);set.add(10);
       
       
       TreeSet<Student> set = new TreeSet<>();
       set.add(学生对象1);
       set.add(学生对象2);
       
       //自定义类实现Comparable接口
       public class Student implements Comparable<Student>{
           public int comparaTo(Student stu){
               
               
               return 0 / 正数  / 负数;
           }
       }
       ~~~

       

    2. 比较器排序

       - 元素不需要具备任何排序方式
       - 在创建TreeSet对象时，指定比较器对象(排序规则)

       ~~~java
       //创建集合对象时，指定比较器
       TreeSet<Student> set = new TreeSet<>( new Comparator<Student>(){
           //重写方法
           public int compare(Student stu1 , Student stu2){
               //stu1 ： 要存储的元素
               //stu2 :  已存在的元素
           }  
       } );
       
       
       //不需要实现任何接口
       public class Student{
           //成员变量
           //成员方法
       }
       ~~~

       





可变参数：

- 在java语言提供了一种特殊的参数：可变参数（可以改变的参数）

  - 在调用方法时，传递的参数可以是任意个（底层：是使用数组）

- 语法格式：

  ~~~java
  public 返回值类型 方法名(参数类型... 参数名){
      //... 就是可变参数的语法表示形式
  }
  ~~~

  

Collections工具类：

- 不能创建对象
- 提供了静态方法
- 针对List、Set集合进行相关操作（排序、二分查找、添加元素、....）



















三大集合：List、Set、Map

1. List （单列集合： 集合在存储元素时，一次只能存储一个元素）

2. Map  （双列集合：集合在存储元素时，一次存储两个元素[key元素 、 value元素]）
3. Set   （单列集合）



## Map集合

map集合的特点：

1. 可以存储两个元素（键值对元素）
2. key元素不能重复， value元素允许重复
3. 一个key元素只能对应一个value元素（一一对应）//通过key可以找到value
4. 存取元素不保证顺序
5. 没有索引



java.util.Map（接口）

- HashMap：底层使用哈希表
- LinkedHashMap：底层使用哈希表+链表
- TreeMap：底层使用红黑树





Map集合不能直接遍历（只能间接性实现遍历操作）

Map集合遍历方式：

1. 键找值

   - 获取Map集合中所有的key元素，遍历所有的key元素，通过key元素找到对应的value元素

   ~~~java
   Set  存储所有key的Set集合对象 =  map集合.keySet();
   ~~~

   

2. 键值对

   - 获取Map集合中所有的Map.Entry， 遍历所有的Map.Entry，通过Entry中的API方法获取到key、value

   ~~~java
   Set<Map.Entry>  存储所有键值对对象的Set集合对象 =  map集合.entrySet();
   
   Map.Entry：
       Object  getKey()
       Object  getValue()
   ~~~

   



在Map集合中当key存储的是自定义对象时，要保证对象存储数据的唯一性，需要：自定义对象中重写hashCode、equals方法







TreeMap集合

- 特点：存储的key元素，会按照指定规则排序
  - 排序方式：
    1. 自然排序： 元素自身实现Comparable接口
    2. 比较器排序：在创建集合对象时，指定比较器

~~~java
TreeMap<String,String> map = new TreeMap<>(); //String类要具备自然排序
TreeMap<Student,String> map = new TreeMap<>();//Student类要具备自然排序

TreeMap<Student,String> map = new TreeMap<>( Comparator对象 );//指定比较器对象 
~~~

